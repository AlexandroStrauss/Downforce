<!DOCTYPE html>
<html>

<head>
    <title>My first three.js app</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script src="js/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="GLTFLoader.js"></script>
    <script>
        var rightPressed = false;
        var leftPressed = false;
        var upPressed = false;
        var downPressed = false;

        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);

    function keyDownHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = true;
        }
        else if (e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = true;
        }
        else if (e.key == "Up" || e.key == "ArrowUp") {
            upPressed = true;
        }
        else if (e.key == "Down" || e.key == "ArrowDown") {
            downPressed = true;
        }
    }

    function keyUpHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = false;
        }
        else if (e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = false;
        }
        else if (e.key == "Up" || e.key == "ArrowUp") {
            upPressed = false;
        }
        else if (e.key == "Down" || e.key == "ArrowDown") {
            downPressed = false;
        }
    }


        var velocity = 0;
        var velX = 0;
        var velZ = 0;
        var angle = 0;

        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0xff0000);

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var loader = new THREE.GLTFLoader();

        var car;

        loader.load('2018_nascar_camaro/scene.gltf', function (gltf) {
            car = gltf.scene;
            scene.add(gltf.scene); 
        }, undefined, function (error) {
            console.error(error);
        })

        var geometry = new THREE.BoxGeometry(100, 300, 100);
        var material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        var tower = new THREE.Mesh(geometry, material);
        var tower2 = new THREE.Mesh(geometry, material);
        scene.add(tower);
        scene.add(tower2);
        tower2.position.set(100, 0, 100);

        var frontstretchGeometry = new THREE.BoxGeometry(100, 100, 1000);
        var frontstretchMaterial = new THREE.MeshBasicMaterial({ color: 0xff7800});
        var frontstretch = new THREE.Mesh(frontstretchGeometry, frontstretchMaterial);
        scene.add(frontstretch);
        frontstretch.position.set(200, 0, 200);

        var cylinderGeometry = new THREE.CylinderGeometry (2000, 2000, 1000, 16,)


        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableKeys = false;

            //controls.update() must be called after any manual changes to the camera's transform
            // camera.position.set(0, 75, 200)
            camera.position.set(0, 1500, 0)
            controls.update();


        var animate = function () {
            requestAnimationFrame(animate);

            // car.rotation.x += 0.02;
            // car.rotation.y += 0.02;
            // car.rotation.z += 0.02;

            // approximate downforce for a NASCAR car, assuming 2000lbs at 180mph
            var downforce = .312 * (Math.pow((velocity * .44704), 2))

            if (upPressed && velocity >= 0) {
                var acceleration = (22.7 - (0.0864 * velocity) - (0.0000892 * Math.pow(velocity, 2)))/60
                velocity += acceleration
            } else if (upPressed && velocity < 0) {
                var deceleration = (-33.6 - 3.12 * Math.log(Math.abs(velocity))) / 20
                velocity -= deceleration
            }

            if (downPressed && velocity > 0) {
                var deceleration = (-33.6 - 3.12 * Math.log(velocity))/60
                velocity += deceleration
            } else if (downPressed && velocity <= 0) {
                velocity = -5;
            }

            // var angleChange = Math.log(1/((Math.abs(velocity) ) / 600))/150;
            var angleChange = velocity/600;

            if (leftPressed) {
                angle += angleChange;
                car.rotation.y += angleChange;
                // camera.rotation.y += angleChange;
            }

            if (rightPressed) {
                angle -= angleChange;
                car.rotation.y -= angleChange;
                // camera.rotation.y -= angleChange;
            }
            
            velocity *= 0.99;
            //these are swapped because of the starting direction of the car.
            //X should be calculated from cosine, Z from sine
            velX = velocity * Math.sin(angle);
            velZ = velocity * Math.cos(angle);
            
            car.position.z -= (velZ)
            car.position.x -= (velX)

            // camera.position.x += (velX)
            // camera.position.z -= (velZ)

            debugger
            controls.update();

            renderer.render(scene, camera);
        };

        animate();
    </script>
</body>

</html>